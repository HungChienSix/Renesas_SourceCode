#include "hal_data.h"
#include "stdio.h"
#include "./Screen/screen.h"

#if (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
bsp_ipc_semaphore_handle_t g_core_start_semaphore =
{
    .semaphore_num = 0
};
#endif

uint32_t clock = 0x00;

void LCD_Test();
void LCD_Test(){
    char info[32] = {0};
    uint32_t time_re;
    uint32_t time_in;

    SCREEN_FillScreen(SCREEN_BLACK);

    // 绘制彩色矩形
    SCREEN_DrawRectSolid(10, 50, 10, 50, SCREEN_RED, SCREEN_Nor);
    SCREEN_DrawRectSolid(60, 100, 10, 50, SCREEN_GREEN, SCREEN_Nor);
    SCREEN_DrawRectSolid(10, 50, 60, 100, SCREEN_BLUE, SCREEN_Nor);
    SCREEN_RefreshScreen();

    // 获取刷新耗时并显示
    time_re = SCREEN_GetRefreshTime();
    time_in = SCREEN_GetRefreshIntervalTime();
    sprintf(info, "T=%4lu,T=%4lu\n", time_re,time_in);
    R_SCI_UART_Write(&g_uart0_ctrl, info, 32);

    R_BSP_SoftwareDelay(1000U, BSP_DELAY_UNITS_MILLISECONDS);

    SCREEN_FillScreen(SCREEN_BLACK);

    // 绘制彩色矩形
    SCREEN_DrawRectSolid(30, 50, 10, 50, SCREEN_RED, SCREEN_Nor);
    SCREEN_DrawRectSolid(10, 100, 10, 50, SCREEN_GREEN, SCREEN_Nor);
    SCREEN_DrawRectSolid(10, 50, 40, 100, SCREEN_BLUE, SCREEN_Nor);
    SCREEN_RefreshScreen();

    // 获取刷新耗时并显示
    time_re = SCREEN_GetRefreshTime();
    time_in = SCREEN_GetRefreshIntervalTime();
    sprintf(info, "T=%4lu,T=%4lu\n", time_re,time_in);
    R_SCI_UART_Write(&g_uart0_ctrl, info, 32);

    R_BSP_SoftwareDelay(1000U, BSP_DELAY_UNITS_MILLISECONDS);
}

/*******************************************************************************************************************//**
 * main() is generated by the RA Configuration editor and is used to generate threads if an RTOS is used.  This function
 * is called by main() when no RTOS is used.
 **********************************************************************************************************************/
void hal_entry(void)
{
    /* TODO: add your own code here */
    // 301 --> LCD_RES
    // 804 --> LCD_DC
    // 803 --> LCD_CS
    // 002 --> LCD_BLK
    fsp_err_t status = FSP_SUCCESS;
    // status = R_IOPORT_Open(&g_ioport_ctrl, &g_ioport.p_cfg);
    status = R_SCI_SPI_Open(&g_spi0_ctrl, &g_spi0_cfg);
    status = R_GPT_Open(&g_timer0_ctrl, &g_timer0_cfg);
    status = R_GPT_Start(&g_timer0_ctrl);
    status = R_SCI_UART_Open(&g_uart0_ctrl, &g_uart0_cfg);

    // assert(FSP_SUCCESS == status);

    SCREEN_Init();

    R_SCI_UART_Write(&g_uart0_ctrl, "Initial OK\n", 11);
    while(1){
        LCD_Test();
    }

    /* Wake up 2nd core if this is first core and we are inside a multicore project. */
#if (0 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && !BSP_TZ_NONSECURE_BUILD

#if BSP_TZ_SECURE_BUILD
    /* Take semaphore so 2nd core can clear it */
    R_BSP_IpcSemaphoreTake(&g_core_start_semaphore);
#endif

    R_BSP_SecondaryCoreStart();

#if BSP_TZ_SECURE_BUILD
    /* Wait for 2nd core to start and clear semaphore */
    while(FSP_ERR_IN_USE == R_BSP_IpcSemaphoreTake(&g_core_start_semaphore))
    {
        ;
    }
#endif
#endif

#if (1 == _RA_CORE) && (1 == BSP_MULTICORE_PROJECT) && BSP_TZ_SECURE_BUILD
    /* Signal to 1st core that 2nd core has started */
    R_BSP_IpcSemaphoreGive(&g_core_start_semaphore);
#endif

#if BSP_TZ_SECURE_BUILD
    /* Enter non-secure code */
    R_BSP_NonSecureEnter();
#endif
}

#if BSP_TZ_SECURE_BUILD

FSP_CPP_HEADER
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ();

/* Trustzone Secure Projects require at least one nonsecure callable function in order to build (Remove this if it is not required to build). */
BSP_CMSE_NONSECURE_ENTRY void template_nonsecure_callable ()
{

}
FSP_CPP_FOOTER

#endif

void time0_callback(timer_callback_args_t *p_args){
    if ( NULL != p_args)
    {
        if(p_args->event == TIMER_EVENT_CYCLE_END ){
            clock++;
        }
    }
}
